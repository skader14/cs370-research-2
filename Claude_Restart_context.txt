# CFR-RL Latency-Aware Extension - Restart Context

## Project Summary

**Goal:** Extend CFR-RL (Zhang et al., arXiv:2004.11986) to measure and optimize for latency, not just Maximum Link Utilization (MLU).

**Research Question:** Does MLU-optimized routing inadvertently hurt latency? Can we do better with a latency-aware objective?

**Status:** Training complete, CloudSimSDN simulations run, initial results collected.

---

## LATEST RESULTS (First Experiment)

| Metric | MLU-only (lw=0.0) | Latency-aware (lw=0.3) | Difference |
|--------|-------------------|------------------------|------------|
| Mean delay | 2.7610s | 2.7598s | -1.21ms (-0.04%) |
| Total delay | 140.81s | 140.75s | -61.56ms |
| Packets | 51 | 51 | - |

**Key Findings:**
1. Results nearly identical on this small workload (51 packets, ~20s)
2. Channel lookup returns null (propagation_delay=0, bandwidth=0) - known bug
3. Need heavier workload to see differentiation
4. Both models beat Top-K by ~5.4% on MLU

**Next Steps for Better Differentiation:**
- Generate longer/heavier workload (500+ packets, 100+ seconds)
- Fix Channel lookup to get proper latency decomposition
- Consider adding latency features to flow selection (research extension)

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│  PYTHON (Training) - COMPLETE                                │
│  - abilene_trainer_latency.py: Trains RL policy             │
│  - abilene_lp_solver_latency.py: LP with latency_weight     │
│  - Outputs: best_abilene_lw0.0.pt, best_abilene_lw0.3.pt   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  JAVA (CloudSimSDN Simulation) - IN PROGRESS                 │
│  - CFRRLExample.java: Main simulation runner                 │
│  - LatencyCollector.java: NEW - records per-packet latency  │
│  - SDNDatacenter.java: MODIFIED - calls LatencyCollector    │
│  - NetworkOperatingSystem.java: MODIFIED - exposes channels │
└─────────────────────────────────────────────────────────────┘
```

---

## Key Concepts

### Latency Weight (LP Objective Modification)
- `latency_weight=0.0`: Pure MLU minimization (original Zhang paper)
- `latency_weight=0.3`: Trades some MLU for lower queuing delay
- Objective: `minimize(U + latency_weight * avg_utilization)`

### Latency Measurement Formula
```
queuing_delay = serve_time - propagation_delay - transmission_delay
where:
  serve_time = finish_time - start_time
  propagation = Channel.getTotalLatency() (physical distance)
  transmission = packet_size / bandwidth
```

### Training Process (REINFORCE)
- No fixed dataset - generates random traffic each iteration
- Policy network scores all 132 flows, samples K=8 to optimize
- LP solver computes optimal routing for selected flows
- Reward = 1/MLU (lower utilization = higher reward)

---

## Training Results Summary

Both models trained successfully:

| Model | Best Eval (iter 500) | Final Eval |
|-------|---------------------|------------|
| MLU-only (lw=0.0) | CFR-RL beats Top-K by 2.1% | CFR-RL beats Top-K by 5.4% |
| Latency-aware (lw=0.3) | CFR-RL beats Top-K by 2.1% | CFR-RL beats Top-K by 5.4% |

**Key observation:** Similar MLU performance, but real latency difference will appear in CloudSimSDN simulation.

---

## Files Modified for Latency Extension

### Java (CloudSimSDN)

1. **LatencyCollector.java** (NEW)
   - Location: `org/cloudbus/cloudsim/sdn/rl/LatencyCollector.java`
   - Purpose: Singleton that collects per-packet latency metrics
   - Key method: `recordPacketCompletion(flowId, packetId, startTime, finishTime, propagationDelay, packetSize, bandwidth, pathLength, srcNode, dstNode)`

2. **NetworkOperatingSystem.java** (MODIFIED)
   - Added: `public Channel findChannel(int srcVmId, int dstVmId, int flowId)`
   - Added: `public ChannelManager getChannelManager()`

3. **SDNDatacenter.java** (MODIFIED)
   - In `processPacketCompleted()`: Added call to `LatencyCollector.recordPacketCompletion()`
   - Added fields: `latencyRecordingEnabled`, `packetsProcessedCount`, `latencyLogFrequency`

4. **CFRRLExampleLatency.java** (NEW)
   - Runner for latency experiments
   - All outputs go to `outputs/` folder

### Python (Training)

5. **abilene_lp_solver_latency.py** (MODIFIED)
   - Added `latency_weight` parameter to `solve()` method
   - New objective: `minimize(U + latency_weight * avg_utilization)`

6. **abilene_trainer_latency.py** (MODIFIED)
   - `TrainingConfig.latency_weight` field
   - Passes `latency_weight` to solver in `train_step()` and `evaluate()`

7. **agent.py** (MODIFIED)
   - Easy model switching via `MODEL_PATH` and `EXPERIMENT_NAME` at top
   - Outputs to `outputs/` folder

---

## Output Folder Structure

All outputs go to the `outputs/` folder for easy organization:

```
outputs/
├── cfrrl_debug_mlu_only.log           # Java debug log (MLU experiment)
├── cfrrl_debug_latency_aware.log      # Java debug log (latency experiment)
├── cfrrl_agent_mlu_only.log           # Python agent log
├── cfrrl_agent_latency_aware.log      # Python agent log
├── latency_results_mlu_only.csv       # Per-packet latency data
└── latency_results_latency_aware.csv  # Per-packet latency data
```

### How to Switch Experiments

**Step 1: Edit agent.py (Python)**
```python
# At top of file, uncomment ONE:
MODEL_PATH = "best_abilene_lw0.0.pt"   # MLU-only
# MODEL_PATH = "best_abilene_lw0.3.pt"   # Latency-aware

EXPERIMENT_NAME = "mlu_only"           # Must match Java
# EXPERIMENT_NAME = "latency_aware"
```

**Step 2: Edit CFRRLExampleLatency.java (Java)**
```java
private static final String EXPERIMENT_NAME = "mlu_only";  // Must match Python
// private static final String EXPERIMENT_NAME = "latency_aware";
```

**Step 3: Run**
```bash
mvn exec:java -Dexec.mainClass="org.cloudbus.cloudsim.sdn.example.CFRRLExampleLatency"
```

---

## Abilene Topology

- 12 nodes (Seattle, Sunnyvale, LosAngeles, Denver, KansasCity, Houston, Chicago, Indianapolis, Atlanta, Washington, NewYork, Jacksonville)
- 30 links with latencies 2-12ms
- 132 flows (12×11 directed pairs)
- K=8 critical flows selected by RL policy

---

## Current State & Next Steps

### Completed
- [x] LatencyCollector.java created and integrated
- [x] SDNDatacenter.java modified to record latency
- [x] NetworkOperatingSystem.java modified to expose findChannel()
- [x] LP solver modified with latency_weight
- [x] Trainer modified to pass latency_weight
- [x] Trained MLU-only model (best_abilene_lw0.0.pt)
- [x] Trained latency-aware model (best_abilene_lw0.3.pt)
- [x] First CloudSimSDN experiment run (results collected)
- [x] Identified Channel lookup bug (findChannel returns null)
- [x] Created fix for Channel lookup bug

### In Progress
- [ ] Apply Channel lookup fix to Packet.java, NOS.java, SDNDatacenter.java
- [ ] Re-run experiments with proper latency decomposition
- [ ] Generate heavier workload for better differentiation

---

## Files Needed to Continue

Upload these files if starting a new chat:

1. **Java files** (to verify integration):
   - LatencyCollector.java
   - SDNDatacenter.java (modified version)
   - NetworkOperatingSystem.java (modified version)
   - CFRRLExampleLatency.java

2. **Python files** (to verify training):
   - abilene_lp_solver_latency.py
   - abilene_trainer_latency.py
   - agent.py (with outputs folder support)

3. **Config files**:
   - abilene-physical.json
   - abilene-virtual.json
   - abilene-workload.csv

4. **Trained models**:
   - best_abilene_lw0.0.pt (MLU-only)
   - best_abilene_lw0.3.pt (latency-aware)

5. **Results** (if available):
   - outputs/latency_results_mlu_only.csv
   - outputs/latency_results_latency_aware.csv

---

## Prompt to Continue

Paste this to start a new conversation:

```
I'm working on extending CFR-RL (Zhang et al., arXiv:2004.11986) to optimize for latency in addition to MLU.

CURRENT STATE:
- Training complete: Models trained with latency_weight=0.0 and 0.3 (both beat Top-K by ~5%)
- CloudSimSDN modified: LatencyCollector records per-packet latency
- First experiment run: Results nearly identical (need heavier workload)
- Known bug: Channel lookup returns null (propagation_delay=0)

ARCHITECTURE:
- Python: trains RL policy to select K=8 critical flows
- Java CloudSimSDN: packet-level simulation, measures actual latency
- LP solver: minimize(U + latency_weight * avg_utilization)

OUTPUT FOLDER STRUCTURE:
All outputs go to outputs/ folder:
- cfrrl_debug_{experiment}.log (Java)
- cfrrl_agent_{experiment}.log (Python)  
- latency_results_{experiment}.csv

KEY CONFIGURATION:
- Edit EXPERIMENT_NAME in both agent.py and CFRRLExampleLatency.java
- Edit MODEL_PATH in agent.py to switch models

RESULTS SO FAR:
- MLU-only mean delay: 2.7610s
- Latency-aware mean delay: 2.7598s (-0.04%)
- Need heavier workload to see real differences

I need help with: [describe current issue]
```

---

## Reference: Zhang Paper Not Required

The key concepts from the Zhang paper are already encoded in the implementation:
- REINFORCE algorithm for policy gradient
- Flow selection as the RL action
- LP solver for optimal routing given selected flows
- MLU minimization as the original objective

The latency extension is our novel contribution.

---

## Bugs Fixed During Development

1. **torch.load() PyTorch 2.6 compatibility**: Add `weights_only=False`
2. **Final eval not loading best model**: Changed from `except: pass` to proper error handling
3. **KeyError 'temperature' on skipped iterations**: Use `self.current_temperature` instead of `metrics['temperature']`

---

## Known Issues (To Fix)

### 1. Channel lookup returns null - **FIX AVAILABLE**

**Symptoms:** `propagation_delay=0` and `bandwidth=0` for all packets in CSV output

**Root Cause:** Race condition in packet completion flow:
1. `processCompletePackets()` sends `SDN_PACKET_COMPLETE` event (queued for later)
2. `updateChannel()` removes channel from table **immediately**
3. Later, `processPacketCompleted()` calls `findChannel()` - but channel is already gone!

**Fix:** Store channel info on the Packet before channel is removed.

**Files to modify:**
1. `Packet.java` - Add 3 fields + getters/setters (see Packet_ADDITIONS.java)
2. `NetworkOperatingSystem.java` - Call `pkt.setChannelInfo()` in `processCompletePackets()` (see NetworkOperatingSystem_FIX.java)
3. `SDNDatacenter.java` - Use `pkt.getChannelXxx()` instead of `findChannel()` (see SDNDatacenter_FIX.java)

**Expected result after fix:**
```
propagation_delay,transmission_delay,queuing_delay,bandwidth,path_length
0.015000,0.091894,1.963500,1000000000,3
```

---

## Research Extension Ideas

### 1. Latency Features in Flow Selection (High Impact)

Currently latency only affects LP objective, not flow selection. Add latency-aware features:

```python
# Current features (4)
features = [demand, num_paths, path_length, bottleneck_capacity]

# Extended features (6+)
features = [
    demand, num_paths, path_length, bottleneck_capacity,
    expected_propagation_delay,  # NEW: From topology
    path_congestion_score,        # NEW: Current link utilizations on path
]
```

### 2. Simulator-in-the-Loop Training (Research Contribution)

Use CloudSimSDN during training for accurate latency feedback:

```
Phase 1: Fast pre-training with LP proxy (~3000 iters)
Phase 2: Fine-tuning with CloudSimSDN (~100 episodes)
         - Run simulation, read latency CSV
         - Update policy based on REAL queuing delays
```

### 3. Dynamic latency_weight

Adjust latency_weight based on network state:
- Low congestion → latency_weight = 0 (pure MLU)
- High congestion → latency_weight = 0.5 (spread load)